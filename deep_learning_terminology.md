
**自分用のメモ書き**
参考文献のほうが図があって、わかりやすいです。

## データ前処理の種類:
- 正規化（Normalization）: 
    入力データの値を特定の範囲にスケーリングし、学習の安定性を向上させる。
    例、画像データのピクセル値を[0, 1]の範囲にスケーリング。
- 平均化（Mean Subtraction）: 
    入力データから平均値を引き、データの中心化を行う。
    これにより、学習の収束性や性能を向上させる。
- PCA（Principal Component Analysis）による次元削減:
    入力データの次元を削減し、
    ネットワークの計算負荷を軽減させる。
    PCAは、データの相関を分析し、重要な情報を保持する主成分のみを用いて次元削減を行う手法。
-  データ拡張（Data Augmentation）:
    入力データを変換してデータセットを拡張し、ネットワークの汎化性能を向上させる。
    例、画像データの水平反転や回転、ランダムな切り取りなどが一般的なデータ拡張の手法。

## 正規化の種類:
- 最小-最大スケーリング(Min-Max Scaling)  :
    データの値を新しい範囲に変換する手法。
    データの最小値を0、最大値を1とし、それ以外の値を0から1の範囲に縮尺する。
- Zスコア正規化(Z-score Normalization)    :
    データの平均と標準偏差を用いてデータを変換する手法。
    データから平均を引き、標準偏差で割ることで、平均0、標準偏差1の正規分布に従うデータに変換する。
- 尺度変換(Scaling)                       :
    データの値を一定の範囲にスケーリングする手法。
    最小値と最大値の間の範囲を指定し、データをその範囲に縮尺する。
- ロバストスケーリング(Robust Scaling)    :
    データの値を中央値と四分位範囲を用いてスケーリングする手法。
    外れ値の影響を抑えることができる。



## ニューラルネットワークの概要:
- 入力層（Input Layer）:
    CNNに入力されるデータを受け取る。
    その値を活性化関数に通じて中間層や出力層に伝播させる。
- 中間層（intermediate layer）:
    入力データから特徴を抽出し、それをより高次元の表現に変換する
    - 畳み込み層（Convolutional Layer）:
        フィルター（カーネル）を使用して入力データ上を畳み込む操作を行い、局所的な特徴の抽出。
        畳み込み層は画像内の特定の特徴やパターンを検出するために使用される。
    - プーリング層（Pooling Layer）:
        畳み込み層の出力を圧縮する役割。
        最大プーリングや平均プーリングなどの操作を行い、特徴マップのサイズを縮小する。
        これにより、位置の変化に対するロバスト性を向上させる。
    - 全結合層（Fully Connected Layer）:
        前の層からの特徴マップをフラットなベクトルに変換し、ニューロンの出力として結合。
        抽出された特徴をもとに分類や予測などのタスクを実行する役割を持つ。
- 出力層（Output Layer）:
    タスクに応じた結果を出力。
    分類問題では、各クラスの確率やクラスラベルの予測。
    二値分類ではシグモイド関数、多クラス分類ではソフトマックス関数が使用される。
    回帰問題では、恒等関数（Identity function）を使用し、数値の予測を出力。



## 畳み込み層（Convolution Layer）の役割:
- 画像などの入力データに対してフィルターを適用して特徴マップを生成する層
    - カーネルウィンドウ範囲内の行列に対して、各フィルターのパラメータを掛け合わせて、
        特徴マップを出力する。
    - カーネルウィンドウサイズは通常正方形で定めらる。
        カーネルウィンドウサイズの分、入力画像データ縦横サイズに比べ、
        出力画像データ縦横サイズが小さくなる
    - カーネルウィンドウサイズが 3 × 3、
        入力画像データが 28px × 28px とすると、
        28 - (3 - 1) = 26 、出力画像データは 26px × 26px となる。
    - フィルターの数だけ、特徴マップが出力される。

## 特徴マップ:
- 畳み込み層を通過した後の出力

## フィルター:
- RGB画像の場合でも、各々のフィルターは各要素RGBに対して畳み込み演算を使うので、
    生成される特徴マップの数は変わらない
- 畳み込み層の入力[バッチサイズ, 縦のピクセル数, 横のピクセル数, フィルター数]（画像の場合）
- 畳み込み層の出力[バッチサイズ, 縦のピクセル数, 横のピクセル数, フィルター数]（画像の場合）

## フィルターの種類:
- エッジ検出フィルター            : 水平方向、垂直方向のエッジを検出するためのフィルター
- ブラー/スムージングフィルター   : 画像をぼかすためのフィルター
- シャープニングフィルター        : 画像の輪郭を強調するためのフィルター
- テクスチャ検出フィルター        : 画像内のテクスチャパターンを検出するためのフィルター
- 角度検出フィルター              : 画像内の特定の角度の特徴を検出するためのフィルター
- スケール/サイズ検出フィルター   : 画像内の異なるサイズの特徴を検出するためのフィルター



## プーリング層（Pooling Layer）の役割、入出力:
- 特徴マップのサイズを圧縮
- 入力次元数：[バッチサイズ, 幅, 高さ, チャンネル数]
- 出力次元数：[バッチサイズ, 新しい幅, 新しい高さ, チャンネル数]

## グローバルプーリング層:
- プーリング操作を特徴マップ全体に適用し、各特徴マップの情報を1つの値にまとめる。
- 特徴マップ全体の重要な情報を抽出し、1つの値として表現する。

## プーリング層（Pooling Layer）の種類:
- 最大プーリング（Max Pooling）:
    - プーリング領域内で最も強い特徴を抽出
    - 最も顕著な特徴が保持され、ノイズや不要な情報が削減される
    - 画像内の物体が平行移動してもプーリング結果が変化しないという性質を持つ。
    - 物体の位置や位置合わせに対して、ノイズ(位置のズレ)に強い。
    - 計算速度が平均プーリングよりも速い。(平均を計算しなくて良い)
    - 物体検出や画像分類など、特徴の強調や位置に対する不変性が重要な場合に最大プーリングを用いる
- 平均プーリング（Average Pooling）:
    - プーリング領域内のピクセル値の平均を抽出
    - 画像を滑らかにし、ノイズの軽減や画像の滑らかさが向上する
    - ピクセル値の平均を取るため、最も顕著な特徴が弱められる
    - 特徴が局所的で鮮明な場合、平均プーリングによって特徴がぼやける可能性がある。
    - 画像の平滑化やノイズ軽減が必要な場合に平均プーリングを用いる

## パディング（padding）:
- プーリング時に入力画像よりも出力画像のサイズが、(カーネルウィンドウサイズ - 1)分小さくなる。
- これを防ぐために、入力画像の外側をピクセル値 0 の画素でパディングすることで、
    入力画像と出力画像のサイズが同じとなる。
- 端のデータに対する畳み込み回数が多くなるので、端の特徴をより捉えられるようになる。
- 畳み込み層やプーリング層で出力画像のサイズが小さくなるが、
- ゼロパディングでサイズを増やすと、層の数を増やすことができる。
    - padding = "vaild" ゼロパディングを行わない
    - padding = "same"  ゼロパディングを行う



## ドロップアウト（Dropout）層の役割:
- 正則化の手法の一つ。
- モデルの過学習を抑制し、未知のデータに対しての汎化性能を向上させる。
- ニューラルネットワークの学習中にランダムに
    ノード（ニューロン）を無効化（ドロップアウト）することによって、
    モデルが一部のノードに過度に依存することを防ぐ。



## フラット化（Flatten）層の役割:
- 多次元データを1次元のベクトルに変換することで、後続の層やモデルに適した形式にする。
    - 多くの機械学習モデルは、入力として1次元のベクトル使用することが一般的。
        前層の出力形式が多次元であり、後続の層の入力形式が1次元の場合、
        入力変換としてフラット化が必要となる。
    - 畳み込み層の出力、3次元の特徴マップ（高さ、幅、チャンネル）を1次元に変換し、
        全結合層入力とするために使用される。



## 全層結合（Fully Connected）:
- 入力データの特徴を抽出し、それらの特徴を使用して予測や分類を行う
    1. 特徴抽出     : 入力画像データに重み行列が掛けることで特徴を抽出
    1. 非線形変換   : 非線形活性化関数をモデル化し、複雑なパターンや特徴を表現
    1. 分類・予測   : モデルの予測や分類結果を表示

## 特徴抽出（Feature Extraction）:
- 入力データに重み行列（モデルの学習中に調整されるパラメータ）を掛けることで、
    有用な情報やパターンを抽出するプロセス

## 重み行列のサイズ
- 重み行列[ 縦(出力ノード数) × 横(入力ノード数) ] とすることで、出力ノード数を調整出来る。
- 重み行列 × 入力ベクトル = 出力ベクトル
[ 縦(出力ノード数) × 横(入力ノード数) ] * [ 縦(入力ノード数) × 横1 ] = [ 縦(出力ノード数) × 横1 ]


## 活性化関数（activation function）
- ニューラルネットワークの中間層や出力層において使用される。
- 各ユニット（ニューロン）出力を制御する関数
- 活性化関数は、ユニットの入力値を変換し、出力値を計算する

## 非線形変換（nonlinear transformation）
- 線形ではない関数や変換
- ニューラルネットワークでは、活性化関数に非線形関数が使用される
- 非線形変換によってネットワークがより複雑な関数を表現できる

## 非線形活性化関数
- シグモイド関数（Sigmoid function）:
    S字型の曲線を持ち、入力を0から1または-1から1の範囲に変換する関数
    - ロジスティック関数（Logistic function）:
        入力を0から1の範囲に変換するS字型の曲線を描く関数
        exp(-x)は指数関数 eの -x 乗、xは入力値
        - **_f(x) = 1 / (1 + exp(-x))_**
            入力が大きいほど1に近づき、入力が小さいほど0に近づく
            用途:二値分類問題においての確率表現
    - ハイパボリックタンジェント関数（Hyperbolic tangent function）:
        入力を-1から1の範囲に変換する関数
        - **_f(x) = (exp(x) - exp(-x)) / (exp(x) + exp(-x))_**
            入力が大きいほど1に近づき、入力が0に近いほど0に近づき、入力が小さいほど-1に近づく
            用途:出力を-1から1の範囲に制約する場合などに、中間層や出力層にて用いる
- ハードシグモイド関数（Hard Sigmoid function）:
    - シグモイド関数の近似であり、計算コストが低く、実数の範囲で近似的に非線形な変換を行う。
    - xは入力値、aとbはハードシグモイド関数のパラメータ、通常はa = 0.2, b = 0.5と設定される
        - **_HardSigmoid(x) = max(0, min(1, a*x + b))_**
            入力値が一定範囲内に収まる場合には線形変換、それ以外の場合には0または1を返す。
- ランプ関数（ReLU, Rectified Linear Unit）:
    - 入力が正の値の場合はそのまま出力し、負の値の場合は0を出力する関数。
    - xは入力値、maxは 0 又は x うち大きい方を選ぶ関数
        - **_f(x) = max(0, x)_**
            計算効率性: 入力が負の場合には出力が0となる。複雑な演算がないため、計算効率が高い。
            勾配消失問題（gradient vanishing problem）の緩和: 
            入力が正の場合には勾配が1となり、勾配の減衰を抑制する。
- ソフトマックス関数（Softmax Function）:
    - 入力値を確率として解釈するために使用される関数
    - 複数の入力値の指数関数を計算し、それらの総和で割ることで各クラスの確率分布を得る
    - x_iは入力ベクトルのi番目の要素、Nは入力ベクトルの次元数、expは自然対数の底eの指数関数
        - **_Softmax(x_i) = exp(x_i) / sum(exp(x_j)) for j = 1 to N_**
            出力は0から1の範囲にあり、全ての出力値の総和は1になる
            用途:多クラス分類問題において、出力層で使用され、各クラスの確率表現に用いる

## 線形活性化関数
- 恒等関数（Identity function）:
    - 入力値をそのまま出力する
    - 回帰問題では、目標とする出力が連続値であるため、
        一般的に恒等関数を使用して直接予測値を出力する
        - **_f(x) = x_**


## 損失関数（Loss Function）とは:
- モデルの出力と正解ラベル間の誤差評価方法
    誤差の計算、定量化し、モデルのパラメータの最適化に使用する

## 損失関数（Loss Function）の種類と計算式
- nはデータポイントの数、y_iは実際の目的変数の値、ŷ_iはモデルの予測値、
    Σは合計、iは各データポイント
    - 平均二乗誤差(Mean Squared Error, MSE) : **_MSE = (1/n) * Σ(y_i - ŷ_i)^2_**
    - 平均絶対誤差(Mean Absolute Error, MAE): **_MAE = (1/n) * Σ|y_i - ŷ_i|_**
    - 平滑化絶対誤差(Smooth L1 Loss): **_Smooth L1 Loss = (1/n) * Σ SmoothL1(y_i - ŷ_i)_**
        - **_if |y_i - ŷ_i| < 1,  SmoothL1(y_i - ŷ_i) = 0.5 * (y_i - ŷ_i)^2_**
        - **_if |y_i - ŷ_i| >= 1, SmoothL1(y_i - ŷ_i) = |y_i - ŷ_i| - 0.5_**
    - クロスエントロピー誤差(Cross-Entropy Error, Cross-Entropy Loss): **_= -Σ(y_i * loge ŷ_i)_**
        -  One-hot Vector 型の正解ラベルデータ y_i と loge(モデルの予測値(確率分布) ŷ_i )行列の総和。
            正解ラベルが 0 のものの総和は0、つまり正解のラベル 1 の 
            loge(モデルの予測値(確率分布) ŷ_i ) の総和となる

## 損失関数（Loss Function）の特徴
- MSEは誤差を二乗するので外れ値影響を受けやすい
- MAEは誤差が0の付近でも勾配が大きい
- Smooth L1 Loss は1以上でMAEとなるので、外れ値の影響が小さく、
    1未満でMSEとなるので、誤差が0付近での勾配が小さい


## 勾配降下法 (gradient descent):
- 目的関数 L の最適化アルゴリズム
    
    w    :パラメータ(重み行列)
    L    :目的関数
    dL/dw:勾配
    h    :学習率

```
    - h * dL/dw       : パラメータの更新量
    w = w - h * dL/dw : 更新後のパラメータ 
```

## 確率的勾配降下法（stocastic gradient descent; SGD）
- ミニバッチ学習を用いた勾配降下法
    - 複数のデータの損失を算出し、
        全体の計算時間が劇的に少なくでき、ほとんど確実に局所最適解に収束する
        いくつかのデータをまとめて入力し、それぞれの勾配を計算したあと、
        その勾配の平均値を用いてパラメータの更新を行う方法

        N :データセットの数
        Nb:バッチサイズ = N を イテレーション (iteration)サイズで割ったもの

## 順伝播 (forward propagation)
- u1 :次ノードの活性化関数入力行列
- w1 :1～2層間の重み行列(目的変数の精度上昇の為に調整されるパラメータ)
- h0 :前ノード出力行列(前ノードの活性化関数出力行列など)
- b1 :1層目のバイアスベクトル

```
    u1 = w1 * h0 + b1
```

- a1 :活性化関数
- h1 :活性化関数出力行列
    h1 = a(u1) : 活性化関数入力行列 u1 、活性化関数出力行列 h1
- w2 :2～3層間の重み行列(目的変数の精度上昇の為に調整されるパラメータ)
- b2 :2層目のバイアスベクトル
- y  :出力

```
    y = w2 * h1 + b2
```

- L  :目的関数(最適化したい量を示す関数。損失関数は目的関数の一部)

```
    L = (1/n) * Σ|y_i - ŷ_i|    平均絶対誤差
    L = (1/n) * Σ(y_i - ŷ_i)^2  平均二乗誤差など ※他種類は下記に示す
```

## パラメータ更新量の算出
- N:データ数、 N=1 、誤差評価方法が平均二乗誤差の場合、

```
    L = (y_i - ŷ_i)^2
```

## ニューラルネットワーク全体を一つの関数
```
    y = f(x;Θ)
      = w2 * h1 + b2
      = w2 * a1(u1) + b2
      = w2 * a1(w1 * h0 + b1) + b2
```

## パラメータ w2 の更新量
- 連鎖律（chain rule）を用いて展開する  
- データ数 n = 1、学習率 h の場合、

```
    dL/dw2  = dL/dy * dy/dw2
    dL/dy   = d/dy * (t - y)^2
            = -2(t - y)
    dy/dw2  = d/dy * (y)
            = d/dy * (w2 * h1 + b2)
            = h1
```

パラメータ w2 の更新量は、

```
        w2  = w2 - h * hdL/dw2
            = w2 - h * dL/dy * dy/dw2
            = w2 - h * -2(t - y) * h1
```

学習率 h は学習が進むと大きな値を探す
シンプルな画像認識のタスクでは、初期値 0.1 から 0.01 程度から試される

## パラメータ w1 の更新量
- 連鎖律（chain rule）を用いて展開する

```
    dL/dw1  = dL/dy * dy/dw1
            = dL/dy * dy/dh1 * dh1/w1
            = dL/dy * dy/dh1 * dh1/du1 * du1/dw1
```

dL/dy は上記で求めた値を代入

```
    dL/dy   = -2(t - y)
    dy/dh1  = d/dh1 * (y)
            = d/dh1 * (w2 * h1 + b2)
            = w2
```

- 活性化出力行列 h1 、活性化関数 a1 シグモイド関数の場合、

```
    dh1/du1 = d/du1 * (h1)
            = d/du1 * (a(u1))
            = d/du1 * (1 / (1 + exp(-u1)))
            = - ( - exp(-u1) / ((1 + exp(-u1))^2) )
            = 1 / (1 + exp(-u1)) * exp(-u1) / (1 + exp(-u1))
            = 1 / (1 + exp(-u1)) * (1 + exp(-u1) -  1) / (1 + exp(-u1))
            = 1 / (1 + exp(-u1)) * (1  -  ( 1 / (1 + exp(-u1))))
            = a(u1) * (1 - a(u1))
            = h1 * (1 - h1)
    du1/dw1 = d/dw1 * (u1)
            = d/dw1 * (w1 * h0 + b1)
            = h0
```

パラメータ w1 の更新量は、

```
        w1  = dL/dw1
            = dL/dy * dy/dh1 * dh1/du1 * du1/dw1
            = -2(t - y) * w2 * h1 * (1 - h1) * h0
```

## 誤差逆伝播法 (backpropagation)
- パラメータ w の更新量は
    目的関数 L をパラメータ w で微分し 学習率 h を掛けたもの。
    連鎖律（chain rule）を用いて展開すると、
    出力側から入力側に向かって、順伝番とは逆向きに、
    各関数入力の勾配（関数出力を関数入力で微分したもの）を掛け合わせて行けば、
    パラメータ w についての目的関数 L の勾配が計算できる

## 勾配消失
- シグモイド関数は微分すると勾配が 0 に近づき、
    学習が進まなくなる勾配消失という現象が起きる

```
    dh1/du1 = a(u1) * (1 - a(u1))
```

活性化関数入力 u1 が 0、a(u1)が 0.5 の時に dh1/du1の最大の値 0.25 となる
活性化関数入力 u1 が 0 から離れるとさらに、dh1/du1の値が小さくなる。
シグモイド関数を用いた層が多くなるほど、パラメータの更新量は指数関数的に少なくなる現象



## 正則化（Regularization）とは
- 同じ損失関数の出力に対して、パラメータの値が最小の組み合わせを選択することにより、
    過学習を抑制し、モデルの汎化性能を向上させるための手法
- 損失関数に正規化項を加算した値を、最小化する目的関数とすることで、
    損失の関数の最小化、モデルの汎化を行うことができる。
    - 目的関数 = 損失関数 + 正規化項

## 過学習（Overfitting）とは:
- 訓練データに対しては高い性能を示すが、未知のデータに対しては性能が低下する現象。
- 同じ誤差のモデルであっても、
    - パラメータの値が大きい（複雑なモデル）ほど、
        過学習を起こしていて、訓練データに対して、未知のデータの性能が低い。
    - パラメータの値が小さい（単純なモデル）ほど、
        訓練データに対して、未知のデータも同じ性能が期待できる。

## 正則化（Regularization）の種類
λ :正則化の強さを制御するハイパーパラメータ
w1, w2 二つのパラメータを用いたモデルの場合の正規化項は

- L1 正則化（Lasso 正則化）: 正規化項 **_λ||w|| = λ * (|w1| + |w2|)_**
    - 目的関数への寄与度小さいパラメータが 0 に近づく。
    - パラメータが 0 = そのパラメータ w が掛けられる説明変数はモデルの予測に寄与しない
    - 重要な特徴の選択とノイズの影響の排除が可能。
    - 不要な特徴を除去しモデルの解釈性を向上。
- L2 正則化（Ridge 正則化）: 正規化項 **_λ||w||^2 = λ * (w1^2 + w2^2)_**
    - パラメータが 0 になることはない。
    - 特徴選択のL1正則化よりも弱くなる。
    - 計算コストが低い。
- Elastic Net 正則化 :
    - L1 正則化と L2 正則化を組み合わせた手法。
    - L1 正則化と L2 正則化の利点を組み合わせることで、
      特徴選択とパラメータの縮小の両方を同時に行う。
    - 計算コストが一番高い。

## 正則化（Regularization）の選択
- L1 正則化（Lasso 正則化）:
    - 特徴選択を促進するため、疎なデータセットや高次元のデータセットに選択される
    - 一部の特徴量のみが重要なときに使用
- L2 正則化（Ridge 正則化）:
    - 二乗誤差を最小化することを目指す場合に選択される
    - 全ての特徴量が重要だが、過学習を防ぎたいときに使用
    - ドメイン知識から説明変数の取捨選択が出来るなら、
        Ridge 正規化で全ての説明変数を残しておいたほうが良い



## ハイパーパラメータ:
- 機械学習モデルの設定や制御に使用されるパラメータ
    - モデルの性能や収束速度に影響を与える。
    - 過学習（Overfitting）やアンダーフィッティング（underfitting）を防ぐために重要。

## ハイパーパラメータの種類
- 学習率（Learning Rate）:
    - 勾配降下法におけるパラメータの更新ステップの大きさを制御するパラメータ。
    - 学習率が大きすぎると発散し、小さすぎると収束が遅くなる。
- バッチサイズ（Batch Size）:
    - 学習時に使用されるデータのバッチの大きさを指定するパラメータ。
    - バッチサイズが大きいとメモリ使用量が増え、計算が遅くなる可能性がある。
- エポック数（Number of Epochs）:
    - 学習データセット全体を何回繰り返して学習するかを指定するパラメータ。
    - エポック数が小さいと学習不足、大きいと過学習のリスクが高まる。
- 正則化パラメータ（Regularization Parameter）:
    - 過学習を抑制するために使用されるパラメータ。
    - 正則化の強さを制御する。
- ネットワークの層の数やユニット数:
    - ネットワークのアーキテクチャに関連するパラメータ。
    - 層の数や各層のユニット数を調整することで、モデルの表現能力や学習の速さが変化する。
- ドロップアウト率（Dropout Rate）:
    - ドロップアウトと呼ばれる正則化手法において、ノードを無効化する確率を指定するパラメータ。
    - 過学習軽減用。
- 最適化アルゴリズム（Optimizer）:
    - 最適化アルゴリズムの設定に関連するパラメータ。
    - モーメンタムや重みの減衰率などがある。

## ハイパーパラメータの最適化手法
- グリッドサーチ（Grid Search）:
    - あらかじめ指定されたハイパーパラメータの組み合わせを試す方法。
    - ハイパーパラメータの候補値をグリッド状に設定、
        それぞれの組み合わせについてモデルをトレーニングして性能を評価。
    - 全ての組み合わせを試すため、計算コストが高い。
- ランダムサーチ（Random Search）:
    - 指定されたハイパーパラメータの範囲内からランダムにサンプリングした組み合わせを試す方法。
    - ランダムに選ばれた組み合わせについてモデルをトレーニングし、性能を評価。
    - グリッドサーチと比べて計算コストが低く、広範なハイパーパラメータ探索が可能。
- ベイズ最適化（Bayesian Optimization）:
    - 確率的なモデルを用いてハイパーパラメータの探索空間を探索する方法。
    - モデルの事前知識を利用しながら、最適なハイパーパラメータを探索。
    - 過去の試行結果に基づいて次のハイパーパラメータのサンプルを選択するため、計算効率が高い。
    - 少ない試行回数で良い結果を得ることができる。



## モデル評価指標の種類:
- 正解率（Accuracy）: 
    - モデルの予測が正しい割合を示す指標。
    - 正解したサンプル数を全サンプル数で割った値。
- 適合率（Precision）: 
    - 陽性と予測されたサンプルの中で、実際に陽性である割合を示す指標。
    - 偽陽性を最小限に抑えることが重要な場合に使用される。
- 再現率（Recall）: 
    - 実際の陽性サンプルのうち、モデルが正しく陽性と予測できた割合を示す指標。
    - 偽陰性を最小限に抑えることが重要な場合に使用される。
- F1スコア（F1 Score）: 
    - 適合率と再現率の調和平均を示す指標。
    - 適合率と再現率のバランスを考慮した総合的な評価指標。
- ROC曲線, AUC（Receiver Operating Characteristic curve, Area Under the Curve）: 
    - 二値分類モデルの性能を評価するための指標。
    - 真陽性率と偽陽性率の関係を表したROC曲線と、その曲線下の面積であるAUCが計算される。
- 平均絶対誤差（Mean Absolute Error, MAE）: 
    - 回帰モデルの性能を評価するために使用される指標。
    - 予測値と真値の差の絶対値の平均。
- 平均二乗誤差（Mean Squared Error, MSE）: 
    - 回帰モデルの性能を評価するために使用される指標。
    - 予測値と真値の差の二乗の平均。

## ROC曲線（Receiver Operating Characteristic curve）:
- 二値分類モデルの性能評価を可視化するために使用されるグラフ
    - 二値分類置いて、陰性、陽性確率の闘値を設定することにより、
        陰性、陽性の二値に分類出来る。
        闘値を変更することにより、偽陽性率、真陽性率が変わる。
        各闘値における偽陽性率と真陽性率の関係をプロットした図をROC曲線という。
        - 縦軸:真陽性率（True Positive Rate, TPR）    :実際に陽性データの中で、モデルが陽性判定した確率
        - 横軸:偽陽性率（False Positive Rate, FPR）   :実際に陰性データの中で、モデルが陽性判定した確率
- AUC（Area Under the Curve）:
    - ROC曲線下部の面積
        - AUCが 1 に近いほどモデルの性能が良く、
        - 0.5 に近いほどランダム、
        - 0.5 以下ならばランダムよりも性能が悪い。



## 機械学習タスクの種類
- 分類（Classification）: 
    - サンプルを予め定義されたクラスやカテゴリに分類する問題。
    - スパムメールの検出や画像分類など。
- 回帰（Regression）: 
    - 入力に対して連続値の予測を行う問題。
    - 住宅価格の予測や売上予測など。
- クラスタリング（Clustering）: 
    - 与えられたデータを自動的にグループ化する問題。
    - 似た特徴を持つデータを同じクラスタに割り当て。
- 次元削減（Dimensionality Reduction）: 
    - 高次元のデータをより低次元の特徴空間に変換する問題。
    - データの可視化や特徴の抽出などに利用される。
- 強化学習（Reinforcement Learning）: 
    - エージェントが環境と相互作用しながら学習し、最適な行動を選択する問題。
    - ゲームやロボット制御などの領域で活用される。
- 自然言語処理（Natural Language Processing, NLP）: 
    - テキストや音声データを解析し、自然言語の理解や生成に関する問題。
    - 機械翻訳や感情分析などが含まれる。
- 推薦システム（Recommendation Systems）: 
    - ユーザーの過去の行動や好みに基づいて、アイテムの推薦を行う問題。
    - 映画や商品のレコメンドなど。


## References 参考文献
- KIKAGAKU. (n.d.). ニューラルネットワークの数学（逆伝播）.  
    Retrieved from https://free.kikagaku.ai/tutorial/basic_of_deep_learning/learn/neural_network_basic_backward (Accessed on 23 June 2023).  
- Chainer Team. (n.d.). 13 ニューラルネットワークの基礎  
    Retrieved from https://tutorials.chainer.org/ja/13_Basics_of_Neural_Networks.html (Accessed on 23 June 2023).  
